C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE IAP
OBJECT MODULE PLACED IN .\Output\IAP.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\Library\StdDriver\src\IAP.c LARGE OMF2 OPTIMIZE(7,SPEED) BRO
                    -WSE INCDIR(..\..\..\..\Library\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\LST\IAP.lst) TABS(2) OBJE
                    -CT(.\Output\IAP.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2020 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          /*********************************************************************************************************
             -***
   8            Website: http://www.nuvoton.com
   9            E-Mail : MicroC-8bit@nuvoton.com
  10          **********************************************************************************************************
             -**/
  11          
  12          #include "ML51.h"
  13          unsigned char xdata DIDBuffer[2];
  14          unsigned char xdata PIDBuffer[2];
  15          unsigned char xdata UIDBuffer[9];
  16          unsigned char xdata UCIDBuffer[12];
  17          unsigned char xdata IAPDataBuf[128];
  18          unsigned char xdata IAPCFBuf[5];
  19          
  20          
  21          /**
  22           * @brief       Erase LDROM  
  23           * @param       u16IAPStartAddress define LDROM area start address
  24           * @param       u16IAPDataSize define LDROM need be erase bytes size
  25           * @return      none
  26           * @details     Page erase LDROM area base on data start address 
  27           * @example      Erase_LDROM(0x0000,2048);
  28           */
  29          void LDROM_Erase(unsigned int u16IAPStartAddress,unsigned int u16IAPDataSize)
  30          {   
  31   1          unsigned int u16Count;
  32   1      
  33   1          set_CHPCON_IAPEN;                    // Enable IAP function
  34   1          set_IAPUEN_LDUEN;                    //  LDROM modify Enable
  35   1          IAPFD = 0xFF;                        // IMPORTANT !! To erase function must setting IAPFD = 0xFF 
  36   1          IAPCN = PAGE_ERASE_LDROM;
  37   1          for(u16Count=0x0000;u16Count<(u16IAPDataSize/PAGE_SIZE);u16Count++)            // Loop page erase LDRO
             -M special define address area.
  38   1          {        
  39   2              IAPAL = LOBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
  40   2              IAPAH = HIBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
  41   2              set_IAPTRG_IAPGO_WDCLR;
  42   2          } 
  43   1          clr_IAPUEN_LDUEN;                    // Disable LDROM modify 
  44   1          clr_CHPCON_IAPEN;                    // Disable IAP
  45   1      }
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 2   

  46          
  47          /**
  48           * @brief       LDROM blank check
  49           * @param       u16IAPStartAddress define LDROM area start address
  50           * @param       u16IAPDataSize define LDROM need be erase bytes size
  51           * @return      none
  52           * @details     Check each byte of LDROM is FFH or not.
  53           * @example      LDROM_BlanckCheck(0x0000,2048);
  54           */
  55          void LDROM_Blank_Check(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
  56          {   
  57   1          unsigned int u16Count;
  58   1          set_CHPCON_IAPEN;
  59   1          IAPAL = LOBYTE(u16IAPStartAddress);
  60   1          IAPAH = HIBYTE(u16IAPStartAddress);
  61   1          IAPCN = BYTE_READ_LDROM;
  62   1      
  63   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
  64   1          {   
  65   2              IAPFD = 0x00;    
  66   2              set_IAPTRG_IAPGO;
  67   2              if(IAPFD != 0xFF)
  68   2                while(1);
  69   2              IAPAL++;
  70   2              if(IAPAL == 0x00)
  71   2                IAPAH++;
  72   2          } 
  73   1          clr_CHPCON_IAPEN;
  74   1      }
  75          
  76          /**
  77           * @brief       LDROM program loop
  78           * @param       u16IAPStartAddress define LDROM area start address
  79           * @param       u16IAPDataSize define LDROM need be erase bytes size
  80           * @return      none
  81           * @details     Copy IAPDataBuf to LDROM
  82           * @example      LDROM_Program(0x0000,1024);
  83           */
  84          void LDROM_Program(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
  85          {   
  86   1          unsigned int u16Count;
  87   1      
  88   1          set_CHPCON_IAPEN;
  89   1          set_IAPUEN_LDUEN;
  90   1          IAPAL = LOBYTE(u16IAPStartAddress);
  91   1          IAPAH = HIBYTE(u16IAPStartAddress);
  92   1          IAPCN = BYTE_PROGRAM_LDROM;
  93   1          
  94   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
  95   1          {   
  96   2              IAPFD = IAPDataBuf[u16Count];
  97   2              set_IAPTRG_IAPGO_WDCLR;
  98   2              IAPAL++;
  99   2              if(IAPAL == 0)
 100   2              {
 101   3                  IAPAH++;
 102   3              }
 103   2          } 
 104   1          clr_IAPUEN_LDUEN;
 105   1          clr_CHPCON_IAPEN;
 106   1      }
 107          
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 3   

 108          
 109          /**
 110           * @brief       LDROM check loop
 111           * @param       u16IAPStartAddress define LDROM area start address
 112           * @param       u16IAPDataSize define LDROM need be erase bytes size
 113           * @return      none
 114           * @details     Check with XRAM IAPDataBuf with LDROM
 115           * @example     LDROM_Program_Verify(0x0000,1024);
 116           */
 117          void LDROM_Read_Verify(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 118          {   
 119   1          unsigned int u16Count;
 120   1      
 121   1          set_CHPCON_IAPEN;
 122   1          IAPAL = LOBYTE(u16IAPStartAddress);
 123   1          IAPAH = HIBYTE(u16IAPStartAddress);
 124   1          IAPCN = BYTE_READ_LDROM;
 125   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 126   1          {   
 127   2              IAPFD = 0x00;
 128   2              set_IAPTRG_IAPGO;
 129   2              if (IAPFD != IAPDataBuf[u16Count])    
 130   2                  while(1);
 131   2              IAPAL++;
 132   2              if(IAPAL == 0)
 133   2              {
 134   3                  IAPAH++;
 135   3              }
 136   2          } 
 137   1          clr_CHPCON_IAPEN;
 138   1      }
 139          
 140          /**
 141           * @brief       Erase APROM  
 142           * @param       u16IAPStartAddress define APROM area start address
 143           * @param       u16IAPDataSize define LDROM need be erase bytes size
 144           * @return      none
 145           * @details     Page erase APROM area base on data start address 
 146           * @example     Erase_APROM(0x0000,2048);
 147           */
 148          void APROM_Erase(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 149          {   
 150   1          unsigned int u16Count;
 151   1      
 152   1          set_CHPCON_IAPEN;                    // Enable IAP function
 153   1          set_IAPUEN_APUEN;                    // APROM modify Enable
 154   1          IAPFD = 0xFF;                        // IMPORTANT !! To erase function must setting IAPFD = 0xFF 
 155   1          IAPCN = PAGE_ERASE_APROM;
 156   1          for(u16Count=0x0000;u16Count<u16IAPDataSize/PAGE_SIZE;u16Count++)            // Loop page erase APROM 
             -special define address area.
 157   1          {        
 158   2              IAPAL = LOBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
 159   2              IAPAH = HIBYTE(u16Count*PAGE_SIZE + u16IAPStartAddress);
 160   2              set_IAPTRG_IAPGO_WDCLR; 
 161   2          } 
 162   1          clr_IAPUEN_APUEN;                    // Disable APROM modify 
 163   1          clr_CHPCON_IAPEN;                    // Disable IAP
 164   1      }
 165          
 166          /**
 167           * @brief       APROM blank check
 168           * @param       u16IAPStartAddress define APROM area start address
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 4   

 169           * @param       u16IAPDataSize define APROM need be erase bytes size
 170           * @return      none
 171           * @details     Check each byte of APPROM is FFH or not.
 172           * @example     APROM_Blank_Check(0x0000,2048);
 173           */
 174          void APROM_Blank_Check(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 175          {   
 176   1          unsigned int u16Count;
 177   1        
 178   1          set_CHPCON_IAPEN;
 179   1          IAPAL = LOBYTE(u16IAPStartAddress);
 180   1          IAPAH = HIBYTE(u16IAPStartAddress);
 181   1          IAPCN = BYTE_READ_APROM;
 182   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 183   1          {   
 184   2              IAPFD = 0x00;    
 185   2              set_IAPTRG_IAPGO;
 186   2              if(IAPFD != 0xFF)
 187   2                while(1);
 188   2              IAPAL++;
 189   2              if(IAPAL == 0x00)
 190   2                IAPAH++;
 191   2          } 
 192   1          clr_CHPCON_IAPEN;
 193   1      }
 194          
 195          /**
 196           * @brief       APROM program loop
 197           * @param       u16IAPStartAddress define APROM area start address
 198           * @param       u16IAPDataSize define APROM need be erase bytes size
 199           * @return      none
 200           * @details     Copy APDataBuf to APROM
 201           * @example     APROM_Program(0x0000,1024);
 202           */
 203          void APROM_Program(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 204          {   
 205   1          unsigned int u16Count;
 206   1      
 207   1          set_CHPCON_IAPEN;
 208   1          set_IAPUEN_APUEN;    
 209   1          IAPAL = LOBYTE(u16IAPStartAddress);
 210   1          IAPAH = HIBYTE(u16IAPStartAddress);
 211   1          IAPCN = BYTE_PROGRAM_APROM;
 212   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 213   1          {   
 214   2              IAPFD=IAPDataBuf[u16Count];
 215   2              set_IAPTRG_IAPGO_WDCLR;
 216   2              IAPAL++;
 217   2              if(IAPAL == 0)
 218   2              {
 219   3                  IAPAH++;
 220   3              }
 221   2          } 
 222   1          clr_IAPUEN_APUEN;
 223   1          clr_CHPCON_IAPEN;
 224   1      }
 225          
 226          /**
 227           * @brief       APROM check loop
 228           * @param       u16IAPStartAddress define APROM area start address
 229           * @param       u16IAPDataSize define APROM need be erase bytes size
 230           * @return      none
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 5   

 231           * @details     Check with XRAM IAPDataBuf with APROM
 232           * @example     APROM_Program_Verify(0x0000,1024);
 233           */
 234          void APROM_Read_Verify(unsigned int u16IAPStartAddress, unsigned int u16IAPDataSize)
 235          {   
 236   1          unsigned int u16Count;
 237   1      
 238   1          set_CHPCON_IAPEN;
 239   1          IAPAL = LOBYTE(u16IAPStartAddress);
 240   1          IAPAH = HIBYTE(u16IAPStartAddress);
 241   1          IAPCN = BYTE_READ_APROM;
 242   1          for(u16Count=0;u16Count<u16IAPDataSize;u16Count++)
 243   1          {   
 244   2              IAPFD = 0x00;
 245   2              set_IAPTRG_IAPGO_WDCLR;
 246   2              if (IAPFD != IAPDataBuf[u16Count])
 247   2                  while(1);
 248   2              IAPAL++;
 249   2              if(IAPAL == 0)
 250   2              {
 251   3                  IAPAH++;
 252   3              }
 253   2          } 
 254   1          clr_CHPCON_IAPEN;
 255   1      }
 256          
 257          /**
 258           * @brief       Read UID loop
 259           * @param       none
 260           * @return      none
 261           * @details     IAP command read UID area storage data in XRAM LIB_UIDBuffer[0:8]
 262           * @example     UID_Read();
 263          */
 264          void UID_Read(void)
 265          {   
 266   1          unsigned char u8Count;
 267   1      
 268   1          set_CHPCON_IAPEN;
 269   1          IAPAL = 0x00;
 270   1          IAPAH = 0x00;
 271   1          IAPCN = READ_UID;
 272   1          for(u8Count=0;u8Count<12;u8Count++)
 273   1          {   
 274   2              IAPFD = 0x00;
 275   2              set_IAPTRG_IAPGO;
 276   2              UIDBuffer[u8Count] = IAPFD ;
 277   2              IAPAL++;
 278   2          } 
 279   1          clr_CHPCON_IAPEN;
 280   1      }
 281          
 282          /**
 283           * @brief       Read UCID loop
 284           * @param       none
 285           * @return      none
 286           * @details     IAP command read UCID area storage data in XRAM UCIDBuffer[0:8]
 287           * @example      UCID_Read();
 288           */
 289          void UCID_Read(void)
 290          {   
 291   1          unsigned char u8Count;
 292   1      
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 6   

 293   1          set_CHPCON_IAPEN;
 294   1          IAPAL = 0x20;
 295   1          IAPAH = 0x00;
 296   1          IAPCN = READ_UID;
 297   1          for(u8Count=0;u8Count<12;u8Count++)
 298   1          {   
 299   2              IAPFD = 0x00;
 300   2              set_IAPTRG_IAPGO;
 301   2              UCIDBuffer[u8Count] = IAPFD ;
 302   2              IAPAL++;
 303   2          } 
 304   1          clr_CHPCON_IAPEN;
 305   1      }
 306          
 307          /**
 308           * @brief       Read DID loop
 309           * @param       none
 310           * @return      none
 311           * @details     IAP command read UID area storage data in XRAM LIB_UIDBuffer[0:8]
 312           * @example      UID_Read();
 313          */
 314          void DID_Read(void)
 315          {   
 316   1          unsigned char u8Count;
 317   1      
 318   1          set_CHPCON_IAPEN;
 319   1          IAPAL = 0x00;
 320   1          IAPAH = 0x00;
 321   1          IAPCN = READ_DID;
 322   1          for(u8Count=0;u8Count<2;u8Count++)
 323   1          {   
 324   2              IAPFD = 0x00;
 325   2              set_IAPTRG_IAPGO;
 326   2              DIDBuffer[u8Count] = IAPFD ;
 327   2              IAPAL++;
 328   2          } 
 329   1          clr_CHPCON_IAPEN;
 330   1      }
 331          
 332          /**
 333           * @brief       Read UID loop
 334           * @param       none
 335           * @return      none
 336           * @details     IAP command read UID area storage data in XRAM LIB_UIDBuffer[0:8]
 337           * @example      UID_Read();
 338          */
 339          void PID_Read(void)
 340          {   
 341   1          unsigned char u8Count;
 342   1      
 343   1          set_CHPCON_IAPEN;
 344   1          IAPAL = 0x02;
 345   1          IAPAH = 0x00;
 346   1          IAPCN = READ_DID;
 347   1          for(u8Count=0;u8Count<2;u8Count++)
 348   1          {   
 349   2              IAPFD = 0x00;
 350   2              set_IAPTRG_IAPGO;
 351   2              PIDBuffer[u8Count] = IAPFD ;
 352   2              IAPAL++;
 353   2          } 
 354   1          clr_CHPCON_IAPEN;
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 7   

 355   1      }
 356          
 357          /**
 358           * @brief       Calculate APROM Checksum
 359           * @param       u8IAPStartAddressHiByte: start address high byte
 360             @param       u8ChecksumSize. 0 means full Flash area. size = u8ChecksumSize*256 bytes  
 361           * @return      none
 362           * @details     Calculate APROM Checksum for 256 bytes based on start address. 
 363           * @example     APROM_Checksum_Run(0x3800,1) when start address is 0x3800.
 364          */
 365          void APROM_Checksum_Run(unsigned int u16IAPStartAddress,unsigned char u8ChecksumSize)
 366          {   
 367   1          set_CHPCON_IAPEN;
 368   1          IAPAL = 0x00;
 369   1          IAPAH = u16IAPStartAddress>>8;
 370   1          IAPFD = u8ChecksumSize;
 371   1          IAPCN = RUN_APROM_CHECKSUM;
 372   1          set_IAPTRG_IAPGO;
 373   1          clr_CHPCON_IAPEN;
 374   1      }
 375          
 376          /**
 377           * @brief       Read APROM Checksum
 378           * @param       u8IAPStartAddressHiByte: start address high byte
 379           * @return      Checksum value based on APROM_Checksum_Run setting.
 380           * @details     Read APROM Checksum based on start address.
 381           * @example     APROM_Checksum_Read(0x3800) when start address is 0x3800.
 382          */
 383          unsigned char APROM_Checksum_Read(unsigned int u16IAPStartAddress)
 384          {   
 385   1          unsigned char CheckSumValue;
 386   1          set_CHPCON_IAPEN;
 387   1          IAPAL = 0x00;
 388   1          IAPAH = u16IAPStartAddress>>8;
 389   1          IAPCN = READ_APROM_CHECKSUM;
 390   1          IAPFD = 0x00;
 391   1          set_IAPTRG_IAPGO;
 392   1          CheckSumValue = IAPFD ;
 393   1          clr_CHPCON_IAPEN;
 394   1          return CheckSumValue;
 395   1      }
 396          
 397          /**
 398           * @brief       Calculate LDROM Checksum
 399           * @param       u8IAPStartAddressHiByte: start address high byte
 400           * @return      none
 401           * @details     Calculate LDROM Checksum for 256 bytes based on start address.
 402           * @example     LDROM_Checksum_Run(0x0000,1) when start address is 0x0000 and check 256 bytes.
 403          */
 404          void LDROM_Checksum_Run(unsigned int u16IAPStartAddress, unsigned char u8ChecksumSize)
 405          {   
 406   1          set_CHPCON_IAPEN;
 407   1          IAPAL = 0x00;
 408   1          IAPAH = u16IAPStartAddress>>8;
 409   1          IAPFD = u8ChecksumSize;
 410   1          IAPCN = RUN_LDROM_CHECKSUM;
 411   1          set_IAPTRG_IAPGO;
 412   1          clr_CHPCON_IAPEN;
 413   1      }
 414          
 415          /**
 416           * @brief       Read LDROM Checksum
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 8   

 417           * @param       u8IAPStartAddressHiByte: start address high byte
 418           * @return      Checksum value based on LDROM_Checksum_Run setting.
 419           * @details     Read LDROM Checksum based on start address.
 420           * @example     LDROM_Checksum_Read(0x00) when start address is 0x0000.
 421          */
 422          unsigned char LDROM_Checksum_Read(unsigned int u16IAPStartAddress)
 423          {   
 424   1          unsigned char CheckSumValue;
 425   1          set_CHPCON_IAPEN;
 426   1          IAPAL = 0x00;
 427   1          IAPAH = u16IAPStartAddress>>8;
 428   1          IAPCN = READ_LDROM_CHECKSUM;
 429   1          IAPFD = 0x00;
 430   1          set_IAPTRG_IAPGO;
 431   1          CheckSumValue = IAPFD ;
 432   1          clr_CHPCON_IAPEN;
 433   1          return CheckSumValue;
 434   1      }
 435          /**
 436           * @brief       Calculate SPROM Checksum
 437           * @param       none
 438           * @return      none
 439           * @details     Calculate SPROM Checksum at 0x0180.
 440           * @example     SPROM_Checksum_Run()
 441          */
 442          void SPROM_Checksum_Run(void)
 443          {   
 444   1          set_CHPCON_IAPEN;
 445   1          IAPAL = 0x80;
 446   1          IAPAH = 0x01;
 447   1          IAPCN = RUN_SPROM_CHECKSUM;
 448   1          set_IAPTRG_IAPGO;//set_IAPTRG_IAPGO;
 449   1          clr_CHPCON_IAPEN;
 450   1      }
 451          
 452          /**
 453           * @brief       Read SPROM Checksum
 454           * @param       none
 455           * @return      checksum value based on SPROM setting.
 456           * @details     Read SPROM Checksum at 0x0180.
 457           * @example     SPROM_Checksum_Read()
 458          */
 459          unsigned char SPROM_Checksum_Read(void)
 460          {   
 461   1          unsigned char CheckSumValue;
 462   1          set_CHPCON_IAPEN;
 463   1          IAPAL = 0x80;
 464   1          IAPAH = 0x01;
 465   1          IAPCN = READ_SPROM_CHECKSUM;
 466   1          IAPFD = 1;
 467   1          set_IAPTRG_IAPGO;
 468   1          CheckSumValue = IAPFD ;
 469   1          clr_CHPCON_IAPEN;
 470   1          return CheckSumValue;
 471   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2146    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    158      20
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.55   IAP                                                                   10/06/2021 14:37:15 PAGE 9   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
