C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\main.c LARGE OMF2 OPTIMIZE(7,SPEED) BROWSE INCDIR(..\..\..\..\Library
                    -\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\LST\main.lst) TABS(2) OBJECT(.\Output\main.obj)

line level    source

   1          /*_____ I N C L U D E S ____________________________________________________*/
   2          #include "ML51.h"
   3          
   4          #include  "project_config.h"
   5          
   6          
   7          
   8          /*_____ D E C L A R A T I O N S ____________________________________________*/
   9          volatile uint8_t u8TH0_Tmp = 0;
  10          volatile uint8_t u8TL0_Tmp = 0;
  11          
  12          //UART 0
  13          //bit BIT_TMP;
  14          //bit BIT_UART;
  15          //bit uart0_receive_flag=0;
  16          //unsigned char uart0_receive_data;
  17          
  18          /*_____ D E F I N I T I O N S ______________________________________________*/
  19          volatile uint32_t BitFlag = 0;
  20          volatile uint32_t counter_tick = 0;
  21          
  22          /*_____ M A C R O S ________________________________________________________*/
  23          #define SYS_CLOCK                 (24000000ul)
  24          
  25          
  26          /*_____ F U N C T I O N S __________________________________________________*/
  27          
  28          
  29          void tick_counter(void)
  30          {
  31   1        counter_tick++;
  32   1      }
  33          
  34          uint32_t get_tick(void)
  35          {
  36   1        return (counter_tick);
  37   1      }
  38          
  39          void set_tick(uint32_t t)
  40          {
  41   1        counter_tick = t;
  42   1      }
  43          
  44          void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
  45          {
  46   1          uint16_t i = 0; 
  47   1        
  48   1          for (i = 0; i < nBytes; i++)
  49   1          {
  50   2              if (src[i] != des[i])
  51   2              {
  52   3                  printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
  53   3            set_flag(flag_error , Enable);
  54   3              }
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 2   

  55   2          }
  56   1      
  57   1        if (!is_flag_set(flag_error))
  58   1        {
  59   2            printf("compare_buffer finish \r\n"); 
  60   2          set_flag(flag_error , Disable);
  61   2        }
  62   1      
  63   1      }
  64          
  65          void reset_buffer(void *dest, unsigned int val, unsigned int size)
  66          {
  67   1          uint8_t *pu8Dest;
  68   1      //    unsigned int i;
  69   1          
  70   1          pu8Dest = (uint8_t *)dest;
  71   1      
  72   1        #if 1
  73   1        while (size-- > 0)
  74   1          *pu8Dest++ = val;
  75   1        #else
                memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
                #endif
  78   1        
  79   1      }
  80          
  81          void copy_buffer(void *dest, void *src, unsigned int size)
  82          {
  83   1          uint8_t *pu8Src, *pu8Dest;
  84   1          unsigned int i;
  85   1          
  86   1          pu8Dest = (uint8_t *)dest;
  87   1          pu8Src  = (uint8_t *)src;
  88   1      
  89   1      
  90   1        #if 0
                  while (size--)
                    *pu8Dest++ = *pu8Src++;
                #else
  94   1          for (i = 0; i < size; i++)
  95   1              pu8Dest[i] = pu8Src[i];
  96   1        #endif
  97   1      }
  98          
  99          void dump_buffer(uint8_t *pucBuff, int nBytes)
 100          {
 101   1          uint16_t i = 0;
 102   1          
 103   1          printf("dump_buffer : %2d\r\n" , nBytes);    
 104   1          for (i = 0 ; i < nBytes ; i++)
 105   1          {
 106   2              printf("0x%2X," , pucBuff[i]);
 107   2              if ((i+1)%8 ==0)
 108   2              {
 109   3                  printf("\r\n");
 110   3              }            
 111   2          }
 112   1          printf("\r\n\r\n");
 113   1      }
 114          
 115          void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
 116          {
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 3   

 117   1          int     nIdx, i;
 118   1      
 119   1          nIdx = 0;
 120   1          while (nBytes > 0)
 121   1          {
 122   2              printf("0x%04X  ", nIdx);
 123   2              for (i = 0; i < 16; i++)
 124   2                  printf("%02X ", pucBuff[nIdx + i]);
 125   2              printf("  ");
 126   2              for (i = 0; i < 16; i++)
 127   2              {
 128   3                  if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
 129   3                      printf("%c", pucBuff[nIdx + i]);
 130   3                  else
 131   3                      printf(".");
 132   3                  nBytes--;
 133   3              }
 134   2              nIdx += 16;
 135   2              printf("\n");
 136   2          }
 137   1          printf("\n");
 138   1      }
 139          
 140          void delay(uint16_t dly)
 141          {
 142   1      /*
 143   1        delay(100) : 14.84 us
 144   1        delay(200) : 29.37 us
 145   1        delay(300) : 43.97 us
 146   1        delay(400) : 58.5 us  
 147   1        delay(500) : 73.13 us 
 148   1        
 149   1        delay(1500) : 0.218 ms (218 us)
 150   1        delay(2000) : 0.291 ms (291 us) 
 151   1      */
 152   1      
 153   1        while( dly--);
 154   1      }
 155          
 156          
 157          void send_UARTString(uint8_t* Data)
 158          {
 159   1        #if 1
 160   1        uint16_t i = 0;
 161   1      
 162   1        while (Data[i] != '\0')
 163   1        {
 164   2          #if 1
 165   2          SBUF = Data[i++];
 166   2          #else
                  UART_Send_Data(UART0,Data[i++]);    
                  #endif
 169   2        }
 170   1      
 171   1        #endif
 172   1      
 173   1        #if 0
                uint16_t i = 0;
                
                for(i = 0;i< (strlen(Data)) ;i++ )
                {
                  UART_Send_Data(UART0,Data[i]);
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 4   

                }
                #endif
 181   1      
 182   1        #if 0
                  while(*Data)  
                  {  
                      UART_Send_Data(UART0, (unsigned char) *Data++);  
                  } 
                #endif
 188   1      }
 189          
 190          void send_UARTASCII(uint16_t Temp)
 191          {
 192   1          uint8_t print_buf[16];
 193   1          uint16_t i = 15, j;
 194   1      
 195   1          *(print_buf + i) = '\0';
 196   1          j = (uint16_t)Temp >> 31;
 197   1          if(j)
 198   1              (uint16_t) Temp = ~(uint16_t)Temp + 1;
 199   1          do
 200   1          {
 201   2              i--;
 202   2              *(print_buf + i) = '0' + (uint16_t)Temp % 10;
 203   2              (uint16_t)Temp = (uint16_t)Temp / 10;
 204   2          }
 205   1          while((uint16_t)Temp != 0);
 206   1          if(j)
 207   1          {
 208   2              i--;
 209   2              *(print_buf + i) = '-';
 210   2          }
 211   1          send_UARTString(print_buf + i);
 212   1      }
 213          
 214          
 215          void WakeUp_Timer_ISR (void)   interrupt 17     //ISR for self wake-up timer
 216          {
 217   1        _push_(SFRS); 
 218   1        
 219   1        P33 ^= 1;
 220   1        
 221   1          clr_WKCON_WKTF;                                   //clear interrupt flag
 222   1        _pop_(SFRS);
 223   1      }
 224          
 225          void WKT_Init(void)
 226          {
 227   1        /*
 228   1          target : 62.5 ms , when LXT , u8WKTRLData = 32
 229   1        */
 230   1      
 231   1      //  const unsigned int u8WKTRLData = 128; //  1/ 16
 232   1        const unsigned int u8WKTRLData = 32;  //  1/ 64
 233   1      //  const unsigned int u8WKTRLData = 8; //  1/ 256
 234   1      
 235   1        SFRS = 0;
 236   1      
 237   1        #if 1 // LXT
 238   1        MFP_P55_X32_IN;
 239   1        MFP_P54_X32_OUT;
 240   1        set_CKEN_ELXTEN;                        //step3: Enable LXT.
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 5   

 241   1        while((CKSWT|CLR_BIT6)==CLR_BIT6);      //step4: check clock source status and wait for ready
 242   1        WKCON |= 0x20;
 243   1        #else // LIRC
                WKCON &= 0xDF;
                #endif
 246   1      
 247   1      
 248   1        //WKT Pre-Scalar : 
 249   1      //  WKCON &= 0xF8; WKCON |= 0x02;// 1/ 16 
 250   1        WKCON &= 0xF8; WKCON |= 0x03; //  1/ 64
 251   1      //  WKCON &= 0xF8; WKCON |= 0x04; //  1/ 256
 252   1        
 253   1        /*
 254   1          ML51 TRM 2.01
 255   1          6.8.2 block diagram
 256   1          RWK support 16 bit , when flash size 64K
 257   1          otherwise , support 8 bit
 258   1        */
 259   1        #if 0
                SFRS=0;
                RWKL = 256 - u8WKTRLData;
                
                #else // 64K flash
 264   1        SFRS=2;
 265   1        RWKH = HIBYTE ( 65536ul - u8WKTRLData);   //65535ul-(u8WKTRLData*512ul/1000ul)
 266   1        SFRS=0;
 267   1        RWKL = LOBYTE ( 65536ul - u8WKTRLData);   //65535ul-(u8WKTRLData*512ul/1000ul)
 268   1        #endif
 269   1        
 270   1          ENABLE_WKT_INTERRUPT;             // enable WKT interrupt
 271   1          set_WKCON_WKTR;                   // Wake-up timer run 
 272   1      
 273   1          ENABLE_GLOBAL_INTERRUPT;  
 274   1      }
 275          
 276          void GPIO_Init(void)
 277          {
 278   1        P03_PUSHPULL_MODE;    
 279   1      
 280   1        P33_PUSHPULL_MODE;  
 281   1      }
 282          
 283          void Timer0_IRQHandler(void)
 284          {
 285   1        
 286   1        tick_counter();
 287   1      
 288   1        if ((get_tick() % 1000) == 0)
 289   1        {
 290   2          P03 ^= 1;
 291   2        }
 292   1      
 293   1        if ((get_tick() % 50) == 0)
 294   1        {
 295   2      
 296   2        }
 297   1        P33 ^= 1;
 298   1        
 299   1      }
 300          
 301          //void Timer0_ISR(void) interrupt 1        // Vector @  0x0B
 302          //{
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 6   

 303          //    TH0 = u8TH0_Tmp;
 304          //    TL0 = u8TL0_Tmp;
 305          //    clr_TCON_TF0;
 306          //  
 307          //  Timer0_IRQHandler();
 308          //}
 309          
 310          void Timer0_Init(void)
 311          {
 312   1        uint16_t res = 0;
 313   1      
 314   1        ENABLE_TIMER0_MODE1;
 315   1          TIMER0_FSYS_DIV12;
 316   1        
 317   1        u8TH0_Tmp = HIBYTE(TIMER_DIV12_VALUE_1ms_FOSC_240000);
 318   1        u8TL0_Tmp = LOBYTE(TIMER_DIV12_VALUE_1ms_FOSC_240000); 
 319   1      
 320   1          TH0 = u8TH0_Tmp;
 321   1          TL0 = u8TL0_Tmp;
 322   1      
 323   1          ENABLE_TIMER0_INTERRUPT;                       //enable Timer0 interrupt
 324   1          ENABLE_GLOBAL_INTERRUPT;                       //enable interrupts
 325   1        
 326   1          set_TCON_TR0;                                  //Timer0 run
 327   1      }
 328          
 329          
 330          //void Serial_ISR (void) interrupt 4 
 331          //{
 332          //    _push_(SFRS);
 333          
 334          //    if (RI)
 335          //    {   
 336          //      uart0_receive_flag = 1;
 337          //      uart0_receive_data = SBUF;
 338          //      clr_SCON_RI;                                         // Clear RI (Receive Interrupt).
 339          //    }
 340          //    if  (TI)
 341          //    {
 342          //      if(!BIT_UART)
 343          //      {
 344          //          TI = 0;
 345          //      }
 346          //    }
 347          
 348          //    _pop_(SFRS);  
 349          //}
 350          
 351          
 352          void UART0_Init(void)
 353          {
 354   1        MFP_P31_UART0_TXD;                              // UART0 TXD use P1.6
 355   1        P31_QUASI_MODE;                                  // set P1.6 as Quasi mode for UART0 trasnfer
 356   1        UART_Open(SYS_CLOCK,UART0_Timer3,115200);        // Open UART0 use timer1 as baudrate generate and baud r
             -ate = 115200
 357   1        ENABLE_UART0_PRINTF;
 358   1      
 359   1      
 360   1      //  printf("UART0_Init\r\n");
 361   1      }
 362          
 363          void SYS_Init(void)
C51 COMPILER V9.55   MAIN                                                                  10/06/2021 14:37:13 PAGE 7   

 364          {
 365   1      //  FsysSelect(FSYS_HIRC);
 366   1      
 367   1          ALL_GPIO_QUASI_MODE;
 368   1      //    ENABLE_GLOBAL_INTERRUPT;                // global enable bit  
 369   1      }
 370          
 371          void main (void) 
 372          {
 373   1          SYS_Init();
 374   1      
 375   1      //    UART0_Init();
 376   1        GPIO_Init();
 377   1      //  Timer0_Init();
 378   1      
 379   1        WKT_Init();
 380   1          
 381   1          while(1)
 382   1          {
 383   2      
 384   2          
 385   2          }
 386   1      }
 387          
 388          
 389          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1586    ----
   CONSTANT SIZE    =    119    ----
   XDATA SIZE       =     10      77
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
